
//Inserido reconhecimento 
//AND, OR, XOR e NOT (TRABALHO 1)
//BYTE, SHORT, LONG e FLOAT (TRABALHO 1)
//FINAL, PUBLIC, PRIVATE e PROTECTED (TRABALHO 1)
------------
// Antes do TOKEN CLASS, inserido reconhecimento PUBLIC PRIVATE FINAL PROTECTED,
void classdecl(RecoverySet g) throws ParseEOFException :
{
}
{
try {
   [<PUBLIC> | <PRIVATE> | <PROTECTED>] [<FINAL>] <CLASS>  <IDENT> [ <EXTENDS> <IDENT> ] classbody(g)
}
catch (ParseException e)
{
    consumeUntil(g, e, "classdecl");
}
}

---------------------------
//Inserido LOOKAHEAD(2) antes de "confirmar" que token percente a uma classe, INICIO CLASSE E DO METODO s√£o iguais
void classlist(RecoverySet g) throws ParseEOFException :
{
RecoverySet f = First.classlist.union(g);
}
{
   classdecl(f) [ LOOKAHEAD(2)classlist(g) ]
}
-----------------------------
// METODOS, inserido reconhecimento PUBLIC PRIVATE FINAL PROTECTED
void methoddecl(RecoverySet g) throws ParseEOFException :
{
}
{
try {
   [<PUBLIC> | <PRIVATE> | <PROTECTED>] [<FINAL>] (<BYTE> | <SHORT> |< LONG> | <FLOAT> | <INT> |  <STRING> | <IDENT> ) (<LBRACKET> <RBRACKET>)*
   <IDENT> methodbody(g)
}
catch (ParseException e)
{
   consumeUntil(g, e, "methoddecl");
}
}
-----------------------------
Tem mais que esqueci
